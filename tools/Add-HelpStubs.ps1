Param(
    [string[]]$Targets
)

$ErrorActionPreference = 'Stop'

<#
.SYNOPSIS
Brief description of Get-HelpStubForFunction.
.DESCRIPTION
Extended description of Get-HelpStubForFunction.

.INPUTS
None
.OUTPUTS
None
.EXAMPLE
Get-HelpStubForFunction
.NOTES
Auto-generated by tools/Add-HelpStubs.ps1. Please refine as needed.
#>

<#
.SYNOPSIS
Brief description of Get-HelpStubForFunction.
.DESCRIPTION
Extended description of Get-HelpStubForFunction.

.INPUTS
None
.OUTPUTS
None
.EXAMPLE
Get-HelpStubForFunction
.NOTES
Auto-generated by tools/Add-HelpStubs.ps1. Please refine as needed.
#>

function Get-HelpStubForFunction {
    param(
        [System.Management.Automation.Language.FunctionDefinitionAst]$FunAst
    )

    $paramSections = @()
    if ($FunAst.Parameters) {
        foreach ($p in $FunAst.Parameters) {
            $name = $p.Name.VariablePath.UserPath
            $paramSections += ".PARAMETER $name`nDescription."
        }
    }

    $exampleParams = if ($FunAst.Parameters) { ($FunAst.Parameters | ForEach-Object { " -$($_.Name.VariablePath.UserPath) <value>" }) -join '' } else { '' }

    $help = @(
        '<#',
        '.SYNOPSIS',
        "Brief description of $($FunAst.Name).",
        '.DESCRIPTION',
        "Extended description of $($FunAst.Name).",
        ($paramSections -join "`n"),
        '.INPUTS',
        'None',
        '.OUTPUTS',
        'None',
        '.EXAMPLE',
        ("{0}{1}" -f $FunAst.Name, $exampleParams),
        '.NOTES',
        'Auto-generated by tools/Add-HelpStubs.ps1. Please refine as needed.',
        '#>'
    ) -join "`r`n"

    return $help + "`r`n"
}

<#
.SYNOPSIS
Brief description of Has-CommentHelpAbove.
.DESCRIPTION
Extended description of Has-CommentHelpAbove.

.INPUTS
None
.OUTPUTS
None
.EXAMPLE
Has-CommentHelpAbove
.NOTES
Auto-generated by tools/Add-HelpStubs.ps1. Please refine as needed.
#>

<#
.SYNOPSIS
Brief description of Has-CommentHelpAbove.
.DESCRIPTION
Extended description of Has-CommentHelpAbove.

.INPUTS
None
.OUTPUTS
None
.EXAMPLE
Has-CommentHelpAbove
.NOTES
Auto-generated by tools/Add-HelpStubs.ps1. Please refine as needed.
#>

function Has-CommentHelpAbove {
    param(
        [string[]]$Lines,
        [int]$StartLine
    )

    $i = [Math]::Max(0, $StartLine - 2 - 8) # look up to 8 lines above
    while ($i -lt ($StartLine - 1)) {
        $line = $Lines[$i].Trim()
        if ($line -like '<#*' -or $line -like '<#') { return $true }
        if ($line -ne '' -and $line -notmatch '^(function|param)') { $i++ ; continue }
        $i++
    }
    return $false
}

# Discover default targets
if (-not $Targets -or $Targets.Count -eq 0) {
    $repoRoot = Resolve-Path (Join-Path $PSScriptRoot '..')
    $Targets = @()
    $Targets += (Join-Path $repoRoot 'ADapp.ps1')
    $Targets += (Get-ChildItem -Path (Join-Path $repoRoot 'Modules') -Filter '*.psm1' -File).FullName
}

foreach ($file in $Targets) {
    if (-not (Test-Path $file)) { continue }
    Write-Host "Processing: $file" -ForegroundColor Cyan
    $content = Get-Content -Path $file -Raw -ErrorAction Stop
    $lines = $content -split "`r?`n"

    $tokens = $null; $errors = $null
    $ast = [System.Management.Automation.Language.Parser]::ParseInput($content, [ref]$tokens, [ref]$errors)
    if ($errors -and $errors.Count -gt 0) {
        Write-Warning "Skipping due to parse errors: $file"
        continue
    }

    $funcAsts = $ast.FindAll({ param($n) $n -is [System.Management.Automation.Language.FunctionDefinitionAst] }, $true)
    if (-not $funcAsts -or $funcAsts.Count -eq 0) { continue }

    # Insert stubs from bottom to top to preserve positions
    $changed = $false
    foreach ($fun in ($funcAsts | Sort-Object { $_.Extent.StartLineNumber } -Descending)) {
        $start = $fun.Extent.StartLineNumber
        if (Has-CommentHelpAbove -Lines $lines -StartLine $start) { continue }
        $stub = Get-HelpStubForFunction -FunAst $fun
        $insertIndex = $start - 1
        $before = $lines[0..($insertIndex - 1)]
        $after = $lines[$insertIndex..($lines.Length - 1)]
        $newLines = @()
        $newLines += $before
        $newLines += $stub
        $newLines += $after
        $lines = $newLines
        $changed = $true
    }

    if ($changed) {
        $newContent = ($lines -join "`r`n")
        Set-Content -Path $file -Value $newContent -NoNewline -Encoding UTF8
        Write-Host "Updated: $file" -ForegroundColor Green
    } else {
        Write-Host "No changes needed: $file" -ForegroundColor DarkGray
    }
}

Write-Host "Help stub insertion completed." -ForegroundColor Green
